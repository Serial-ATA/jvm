#![allow(non_snake_case)]

pub mod intrinsics;
pub mod jni;
mod lookup;

use crate::reference::Reference;
use crate::stack::local_stack::LocalStack;
use crate::thread::ThreadRef;

use std::collections::HashMap;
use std::sync::RwLock;

use instructions::Operand;
use once_cell::sync::Lazy;
use symbols::Symbol;

#[derive(Copy, Clone, Eq, Hash, PartialEq)]
pub struct NativeMethodDef {
	pub class: Symbol,
	pub name: Symbol,
	pub descriptor: Symbol,
}

#[macro_export]
macro_rules! include_generated {
	($path:literal) => {
		include!(std::concat!(
			env!("CARGO_MANIFEST_DIR"),
			"/../generated/",
			$path
		));
	};
}

pub struct JNIEnv {
	pub current_thread: ThreadRef,
}

pub type NativeReturn = Option<Operand<Reference>>;
pub type NativeMethodPtr = fn(JNIEnv, LocalStack) -> NativeReturn;

include!("../../../generated/native/native_init.rs"); // Provides `init_native_method_table()`, generated by `runtime/build.rs`
pub(self) static NATIVE_METHOD_TABLE: Lazy<RwLock<HashMap<NativeMethodDef, NativeMethodPtr>>> =
	Lazy::new(|| RwLock::new(init_native_method_table()));

pub fn lookup_method(def: NativeMethodDef) -> NativeMethodPtr {
	NATIVE_METHOD_TABLE.read().unwrap()[&def]
}

pub(self) fn insert_method((def, ptr): (NativeMethodDef, NativeMethodPtr)) {
	NATIVE_METHOD_TABLE.write().unwrap().insert(def, ptr);
}

// Module marker, do not remove
pub(crate) mod jdk {
	pub(crate) mod internal {
		pub(crate) mod misc {
			pub(crate) mod CDS;
			pub(crate) mod VM;
			pub(crate) mod Unsafe;
		}
		pub(crate) mod util {
		pub(crate) mod SystemProps;
		}
		pub(crate) mod reflect {
		pub(crate) mod Reflection;
		}
	}
}

pub(crate) mod java {
	pub(crate) mod lang {
		pub(crate) mod StringBuilder;
		pub(crate) mod Runtime;
		pub(crate) mod StringUTF16;
		pub(crate) mod System;
		pub(crate) mod Float;
		pub(crate) mod ClassLoader;
		pub(crate) mod Double;
		pub(crate) mod Throwable;
		pub(crate) mod Object;
		pub(crate) mod Class;
	}
}

