use crate::objects::class::ClassPtr;
use crate::objects::method::Method;
use crate::objects::reference::Reference;
use crate::stack::local_stack::LocalStack;
use crate::symbols::Symbol;

use std::collections::HashMap;
use std::ffi::c_void;
use std::fmt::Debug;
use std::sync::{LazyLock, RwLock};

use ::jni::env::JniEnv;
use instructions::Operand;

#[derive(Copy, Clone, Eq, Hash, PartialEq)]
pub struct NativeMethodDef {
	pub class: Symbol,
	pub name: Symbol,
	pub descriptor: Symbol,
	pub is_static: bool,
}

impl Debug for NativeMethodDef {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		f.write_fmt(format_args!(
			"{}{}#{}{}",
			if self.is_static { "static " } else { "" },
			self.class.as_str(),
			self.name.as_str(),
			self.descriptor.as_str()
		))
	}
}

pub type NativeReturn = Option<Operand<Reference>>;
pub type NativeStaticMethodPtr = fn(JniEnv, ClassPtr, LocalStack) -> NativeReturn;
pub type NativeNonStaticMethodPtr = fn(JniEnv, LocalStack) -> NativeReturn;

#[derive(Copy, Clone)]
pub enum NativeMethodPtr {
	StaticInternal(NativeStaticMethodPtr),
	NonStaticInternal(NativeNonStaticMethodPtr),
	External(*const c_void),
}

unsafe impl Send for NativeMethodPtr {}
unsafe impl Sync for NativeMethodPtr {}

impl NativeMethodPtr {
	/// Used by the native method generator, should never be used directly.
	#[doc(hidden)]
	pub fn new_static(f: NativeStaticMethodPtr) -> NativeMethodPtr {
		Self::StaticInternal(f)
	}
	/// Used by the native method generator, should never be used directly.
	#[doc(hidden)]
	pub fn new_non_static(f: NativeNonStaticMethodPtr) -> NativeMethodPtr {
		Self::NonStaticInternal(f)
	}

	pub unsafe fn from_raw(ptr: *const ()) -> Self {
		Self::External(ptr as *const c_void)
	}

	pub unsafe fn as_static(self) -> NativeStaticMethodPtr {
		let Self::StaticInternal(ptr) = self else {
			unreachable!()
		};
		ptr
	}

	pub unsafe fn as_non_static(self) -> NativeNonStaticMethodPtr {
		let Self::NonStaticInternal(ptr) = self else {
			unreachable!()
		};
		ptr
	}
}

include!("../../../generated/native/native_init.rs"); // Provides `init_native_method_table()`, generated by `runtime/build.rs`
pub(self) static NATIVE_METHOD_TABLE: LazyLock<RwLock<HashMap<NativeMethodDef, NativeMethodPtr>>> =
	LazyLock::new(|| RwLock::new(init_native_method_table()));

/// Lookup the native method defintion for `method`, or return `None`
pub fn lookup_method(method: &Method) -> Option<NativeMethodPtr> {
	let native_method = NativeMethodDef {
		class: method.class().name(),
		name: method.name,
		descriptor: method.descriptor_sym(),
		is_static: method.is_static(),
	};

	NATIVE_METHOD_TABLE
		.read()
		.unwrap()
		.get(&native_method)
		.copied()
}

/// Insert a new method definition into the native method table
pub(super) fn insert_method((def, ptr): (NativeMethodDef, NativeMethodPtr)) {
	NATIVE_METHOD_TABLE.write().unwrap().insert(def, ptr);
}
