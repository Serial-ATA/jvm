//! Structs used for defining access/property flags

use std::fmt::{Debug, Formatter};
use std::ops::{BitAnd, BitOr, BitXor, Not};

use common::int_types::u2;

/// Implements the required traits for AccessFlags
///
/// Since the access flag types are simply wrappers for `u2`, the `Bit*` implementations are simply
/// performing the operations on `self.0`,
macro_rules! impl_accessflags_for {
	($impl_for:ident) => {
		impl From<u2> for $impl_for {
			fn from(value: u2) -> $impl_for {
				Self(value)
			}
		}

		impl Debug for $impl_for {
			fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
				f.write_fmt(format_args!("{}", self.0))
			}
		}

		impl BitOr for $impl_for {
			type Output = Self;

			fn bitor(self, rhs: Self) -> Self::Output {
				Self(self.0 | rhs.0)
			}
		}

		impl BitAnd for $impl_for {
			type Output = Self;

			fn bitand(self, rhs: Self) -> Self::Output {
				Self(self.0 & rhs.0)
			}
		}

		impl BitXor for $impl_for {
			type Output = Self;

			fn bitxor(self, rhs: Self) -> Self::Output {
				Self(self.0 ^ rhs.0)
			}
		}

		impl Not for $impl_for {
			type Output = Self;

			fn not(self) -> Self::Output {
				Self(!self.0)
			}
		}

		impl AccessFlags for $impl_for {}
	};
}

/// Creates the `is_*` methods
macro_rules! impl_is_methods {
	(impl $impl_for:ident {
		$($method_name:ident => $associated_const:ident);+ $(;)?
	}) => {
		impl $impl_for {
			$(
				pub fn $method_name(self) -> bool {
					self.0 & Self::$associated_const.0 > 0
				}
			)+
		}
	}
}

pub trait AccessFlags: From<u2> + Debug + Eq + Ord + BitOr + BitAnd + BitXor + Not {}

/// Method access and property flags (§4.1-B)
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct ClassAccessFlags(u16);

#[rustfmt::skip]
impl ClassAccessFlags {
	// Access flags
	// https://docs.oracle.com/javase/specs/jvms/se19/html/jvms-4.html#jvms-4.1-200-E.1

	pub const ACC_PUBLIC    : ClassAccessFlags = Self(0x0001); /* Declared public; may be accessed from outside its package. */
	pub const ACC_FINAL     : ClassAccessFlags = Self(0x0010); /* Declared final; no subclasses allowed. */
	pub const ACC_SUPER     : ClassAccessFlags = Self(0x0020); /* Treat superclass methods specially when invoked by the invokespecial instruction. */
	pub const ACC_INTERFACE : ClassAccessFlags = Self(0x0200); /* Is an interface, not a class. */
	pub const ACC_ABSTRACT  : ClassAccessFlags = Self(0x0400); /* Declared abstract; must not be instantiated. */
	pub const ACC_SYNTHETIC : ClassAccessFlags = Self(0x1000); /* Declared synthetic; not present in the source code. */
	pub const ACC_ANNOTATION: ClassAccessFlags = Self(0x2000); /* Declared as an annotation interface. */
	pub const ACC_ENUM      : ClassAccessFlags = Self(0x4000); /* Declared as an enum class. */
	pub const ACC_MODULE    : ClassAccessFlags = Self(0x8000); /* Is a module, not a class or interface. */
	
	pub const NONE          : ClassAccessFlags = Self(0);      /* No flags set, used internally */
}

impl_accessflags_for!(ClassAccessFlags);

impl_is_methods! {
	impl ClassAccessFlags {
		is_public       => ACC_PUBLIC;
		is_final        => ACC_FINAL;
		is_super        => ACC_SUPER;
		is_interface    => ACC_INTERFACE;
		is_abstract     => ACC_ABSTRACT;
		is_synthetic    => ACC_SYNTHETIC;
		is_annotation   => ACC_ANNOTATION;
		is_enum         => ACC_ENUM;
		is_module       => ACC_MODULE;
	}
}

/// Method access and property flags (§4.6-A)
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct MethodAccessFlags(u16);

#[rustfmt::skip]
impl MethodAccessFlags {
	// Access flags
	// https://docs.oracle.com/javase/specs/jvms/se19/html/jvms-4.html#jvms-4.6-200-A.1

	pub const ACC_PUBLIC      : MethodAccessFlags = Self(0x0001); /* Declared public; may be accessed from outside its package. */
	pub const ACC_PRIVATE     : MethodAccessFlags = Self(0x0002); /* Declared private; accessible only within the defining class and other classes belonging to the same nest (§5.4.4). */
	pub const ACC_PROTECTED   : MethodAccessFlags = Self(0x0004); /* Declared protected; may be accessed within subclasses. */
	pub const ACC_STATIC      : MethodAccessFlags = Self(0x0008); /* Declared static. */
	pub const ACC_FINAL       : MethodAccessFlags = Self(0x0010); /* Declared final; must not be overridden (§5.4.5). */
	pub const ACC_SYNCHRONIZED: MethodAccessFlags = Self(0x0020); /* Declared synchronized; invocation is wrapped by a monitor use. */ // TODO: This is not respected anywhere
	pub const ACC_BRIDGE      : MethodAccessFlags = Self(0x0040); /* A bridge method, generated by the compiler. */
	pub const ACC_VARARGS     : MethodAccessFlags = Self(0x0080); /* Declared with variable number of arguments. */
	pub const ACC_NATIVE      : MethodAccessFlags = Self(0x0100); /* Declared native; implemented in a language other than the Java programming language. */
	pub const ACC_ABSTRACT    : MethodAccessFlags = Self(0x0400); /* Declared abstract; no implementation is provided. */
	pub const ACC_STRICT      : MethodAccessFlags = Self(0x0800); /* In a class file whose major version number is at least 46 and at most 60: Declared strictfp. */
	pub const ACC_SYNTHETIC   : MethodAccessFlags = Self(0x1000); /* Declared synthetic; not present in the source code. */

	pub const NONE            : MethodAccessFlags = Self(0);      /* No flags set, used internally */
}

impl_accessflags_for!(MethodAccessFlags);

impl_is_methods! {
	impl MethodAccessFlags {
		is_public       => ACC_PUBLIC;
		is_private      => ACC_PRIVATE;
		is_protected    => ACC_PRIVATE;
		is_static       => ACC_STATIC;
		is_final        => ACC_FINAL;
		is_synchronized => ACC_SYNCHRONIZED;
		is_bridge       => ACC_BRIDGE;
		is_varargs      => ACC_VARARGS;
		is_native       => ACC_NATIVE;
		is_abstract     => ACC_ABSTRACT;
		is_strict       => ACC_STRICT;
		is_synthetic    => ACC_SYNTHETIC;
	}
}

/// Field access and property flags (§4.5-A)
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct FieldAccessFlags(u16);

#[rustfmt::skip]
impl FieldAccessFlags {
	// Access flags
	// https://docs.oracle.com/javase/specs/jvms/se19/html/jvms-4.html#jvms-4.5-200-A.1

	pub const ACC_PUBLIC   : FieldAccessFlags = Self(0x0001); /* Declared public; may be accessed from outside its package. */
	pub const ACC_PRIVATE  : FieldAccessFlags = Self(0x0002); /* Declared private; accessible only within the defining class and other classes belonging to the same nest (§5.4.4). */
	pub const ACC_PROTECTED: FieldAccessFlags = Self(0x0004); /* Declared protected; may be accessed within subclasses. */
	pub const ACC_STATIC   : FieldAccessFlags = Self(0x0008); /* Declared static. */
	pub const ACC_FINAL    : FieldAccessFlags = Self(0x0010); /* Declared final; never directly assigned to after object construction (JLS §17.5). */
	pub const ACC_VOLATILE : FieldAccessFlags = Self(0x0040); /* Declared volatile; cannot be cached. */
	pub const ACC_TRANSIENT: FieldAccessFlags = Self(0x0080); /* Declared transient; not written or read by a persistent object manager. */
	pub const ACC_SYNTHETIC: FieldAccessFlags = Self(0x1000); /* Declared synthetic; not present in the source code. */
	pub const ACC_ENUM 	   : FieldAccessFlags = Self(0x4000); /* Declared as an element of an enum class. */

	pub const NONE         : FieldAccessFlags = Self(0);      /* No flags set, used internally */
}

impl_accessflags_for!(FieldAccessFlags);

impl_is_methods! {
	impl FieldAccessFlags {
		is_public    => ACC_PUBLIC;
		is_private   => ACC_PRIVATE;
		is_protected => ACC_PRIVATE;
		is_static    => ACC_STATIC;
		is_final     => ACC_FINAL;
		is_volatile  => ACC_VOLATILE;
		is_transient => ACC_TRANSIENT;
		is_synthetic => ACC_SYNTHETIC;
		is_enum      => ACC_ENUM;
	}
}
